import{g as I,a as E,b as M,c as S,d as T,e as k,f as N,u as j,h as C,i as R}from"./main-CZPlR-FP.js";import"./index-D87lGZx0.js";const $="https://api.openai.com/v1";class P{async responseCompletion(t,n,r={}){const s=I();if(!s)throw new Error("OpenAI API key is not set.");const{model:i=E(),name:o="structured_output",temperature:p=.3}=r,d={"Content-Type":"application/json",Authorization:`Bearer ${s}`},h={model:i,input:t,text:{format:{type:"json_schema",name:o,schema:n,strict:!0}}},l=await fetch(`${$}/responses`,{method:"POST",headers:d,body:JSON.stringify(h)});if(!l.ok){const u=await l.text();throw console.error("OpenAI Responses API Error:",u),new Error(`OpenAI Responses API request failed: ${l.status} ${l.statusText}`)}const m=await l.json();return J(m)}}function J(e){var s,i;const t=(s=e.output)==null?void 0:s.find(o=>o.type==="message"),n=(i=t==null?void 0:t.content)==null?void 0:i.find(o=>o.type==="output_text"),r=n==null?void 0:n.text;if(!r)throw console.error("Could not find output_text in OpenAI response. Full response:",JSON.stringify(e,null,2)),new Error("OpenAI response missing structured output text.");try{return typeof r=="string"?JSON.parse(r):r}catch(o){throw console.error("Failed to parse structured output text as JSON:",r),o}}const L=new P;function _(e){let t;if(console.log("Received the following content:"),console.log(e),typeof e=="string")try{t=JSON.parse(e.trim())}catch{throw console.error("Invalid JSON string returned from AI:",e),new Error("AI response could not be parsed as JSON.")}else t=e;if(!t||typeof t!="object"||!Array.isArray(t.result))throw new Error('Expected an object with a top-level "result" array.');return t.result.map((r,s)=>{if(typeof r!="object"||!Array.isArray(r.n))throw new Error(`Track ${s} is malformed or missing "n" array.`);return{n:r.n.map(o=>{if(typeof o!="object"||typeof o.p!="string"||typeof o.s!="number"||typeof o.d!="number")throw new Error(`Invalid note in track ${s}: ${JSON.stringify(o)}`);return{pitch:o.p,start:o.s,duration:o.d}})}})}async function B(e,t=8){const n=I(),r=E();if(!n||!r)throw new Error("OpenAI key or model is not set in user config.");const s="You are a musical AI. You receive songs as input JSON and extend the song.",i=`Extend each of the ${e.length} tracks by exactly ${t} beats. 
Preserve the key of the input. Develop existing motives with coherent phrasing, rhythm, and voice-leading. 
Maintain harmonic logic and linearity (e.g., Schenkerian principles). Avoid unmotivated modulations or gestures. 
Return only the new notes.

Format strictly:
Each track is an object with key "n", a list of notes.
Each note: { "p": "<pitch>", "s": <start>, "d": <duration>" }

INPUT TRACKS:
${JSON.stringify(e,null,2)}`,o=[{role:"system",content:s},{role:"user",content:i}],p={type:"object",properties:{result:{type:"array",items:{type:"object",properties:{n:{type:"array",items:{type:"object",properties:{p:{type:"string"},s:{type:"number"},d:{type:"number"}},required:["p","s","d"],additionalProperties:!1}}},required:["n"],additionalProperties:!1}}},required:["result"],additionalProperties:!1};try{const d=await L.responseCompletion(o,p,{model:r,temperature:.3,name:"track_array"});return console.log("Received response from OpenAI"),console.log(d),_(d)}catch(d){throw console.error("AI extension failed:",d),new Error("Failed to extend tracks with AI.")}}function F(e){if(!Array.isArray(e))throw new Error("sequencers must be an array.");return e.map(t=>{if(!t||!Array.isArray(t.notes))throw new Error("Invalid sequencer object encountered during conversion.");return{n:t.notes.map(n=>[n.pitch,n.start,n.duration])}})}function q(e,t,n){if(!e||!Array.isArray(e.n))throw new Error("Invalid trackMap provided.");return{n:e.n.filter(([s,i,o])=>{const p=i+o;return i>=t&&p<=n})}}function K(e,t,n){if(!Array.isArray(e))throw new Error("trackMaps must be an array.");return e.map(r=>q(r,t,n))}function U(e,t){if(!(e!=null&&e.n)||!(t!=null&&t.n))throw new Error("Invalid track maps provided.");return{n:[...e.n,...t.n]}}function Y(e,t){if(!Array.isArray(e)||!Array.isArray(t))throw new Error("Both track arrays must be arrays.");if(e.length!==t.length)throw new Error("Track arrays must have the same number of tracks.");return e.map((n,r)=>U(n,t[r]))}async function G(){var t;const e=document.getElementById("ai-working-modal");if(e){e.classList.remove("hidden");try{const n=M(),r=Array.from(document.querySelectorAll('#extend-track-checkboxes input[type="checkbox"]:checked')).map(a=>parseInt(a.dataset.index??"0",10));if(r.length===0){console.warn("No tracks selected for AI extension."),e.classList.add("hidden");return}const s=r.map(a=>n[a]),i=S(),o=Math.max(0,i-T()),p=i,d=F(s),l=K(d,o,p).map(a=>({n:a.n.map(c=>({pitch:c[0],start:c[1],duration:c[2]}))})),m=await B(l,k());console.log("ðŸ§  AI Extension Result:",m);const u=m.map(a=>({n:a.n.map(c=>[c.pitch,c.start,c.duration])}));if(!u||u.length!==s.length)throw new Error("AI response did not return expected number of tracks.");const f=Y(d,u),b=f.flatMap(a=>a.n.map(c=>c[1]+c[2])),v=Math.max(...b),y=Math.ceil(v/N());j(y),n.forEach((a,c)=>{var x;a.updateTotalMeasures(y);const w=r.indexOf(c);if(w!==-1){const O=f[w];a.updateNotesFromTrackMap(O)}(x=a.grid)==null||x.scheduleRedraw();const A=a.container.querySelector("canvas.mini-contour");A&&C(A,a.notes,a.config,a.colorIndex)});const g=document.getElementById("global-mini-contour");g&&R(g,n),console.log("ðŸŽ¼ Sequencers updated with AI-generated continuation."),console.log(`ðŸŽ¼ Total measures extended to ${y} based on AI content.`),(t=document.getElementById("ai-extend-modal"))==null||t.classList.add("hidden"),e.classList.add("hidden")}catch(n){console.error("Error during AI extension:",n),e.classList.add("hidden");const r=document.getElementById("ai-generation-failed-modal");if(r){r.classList.remove("hidden");const s=document.getElementById("generation-failed-ok");s==null||s.addEventListener("click",()=>{r.classList.add("hidden")},{once:!0})}}}}export{G as extendTracksWithAI};
