import{g as A,a as I,b as v,c as O,d as M,e as S,f as T,u as k,h as N,i as j}from"./main-PhjSGlxY.js";import"./index-h8Q-9sQm.js";const C="https://api.openai.com/v1";class ${async responseCompletion(t,n,{model:r=I(),name:s="structured_output",temperature:i=.3}={}){const o=A();if(!o)throw new Error("OpenAI API key is not set.");const d={"Content-Type":"application/json",Authorization:`Bearer ${o}`},c={model:r,input:t,text:{format:{type:"json_schema",name:s,schema:n,strict:!0}}},l=await fetch(`${C}/responses`,{method:"POST",headers:d,body:JSON.stringify(c)});if(!l.ok){const p=await l.text();throw console.error("OpenAI Responses API Error:",p),new Error(`OpenAI Responses API request failed: ${l.status} ${l.statusText}`)}const u=await l.json();return P(u)}}function P(e){var s,i;const t=(s=e.output)==null?void 0:s.find(o=>o.type==="message"),n=(i=t==null?void 0:t.content)==null?void 0:i.find(o=>o.type==="output_text"),r=n==null?void 0:n.text;if(!r)throw console.error("Could not find output_text in OpenAI response. Full response:",JSON.stringify(e,null,2)),new Error("OpenAI response missing structured output text.");try{return typeof r=="string"?JSON.parse(r):r}catch(o){throw console.error("Failed to parse structured output text as JSON:",r),o}}const R=new $;function J(e){let t;if(console.log("Received the following content:"),console.log(e),typeof e=="string")try{t=JSON.parse(e.trim())}catch{throw console.error("Invalid JSON string returned from AI:",e),new Error("AI response could not be parsed as JSON.")}else t=e;if(!t||typeof t!="object"||!Array.isArray(t.result))throw new Error('Expected an object with a top-level "result" array.');return t.result.map((r,s)=>{if(typeof r!="object"||!Array.isArray(r.n))throw new Error(`Track ${s} is malformed or missing "n" array.`);return{n:r.n.map(o=>{if(typeof o!="object"||typeof o.p!="string"||typeof o.s!="number"||typeof o.d!="number")throw new Error(`Invalid note in track ${s}: ${JSON.stringify(o)}`);return[o.p,o.s,o.d]})}})}async function B(e,t=8){const n=A(),r=I();if(!n||!r)throw new Error("OpenAI key or model is not set in user config.");const s="You are a musical AI. You receive songs as input JSON and extend the song.",i=`Extend each of the ${e.length} tracks by exactly ${t} beats. 
  Preserve the key of the input. Develop existing motives with coherent phrasing, rhythm, and voice-leading. 
  Maintain harmonic logic and linearity (e.g. Schenkerian principles). Avoid unmotivated modulations or gestures. 
  Return only the new notes.
  
  Format strictly:
  Each track is an object with key "n", a list of notes.
  Each note: { "p": "<pitch>", "s": <start>, "d": <duration> }
  
  INPUT TRACKS:
  ${JSON.stringify(e,null,2)}`,o=[{role:"system",content:s},{role:"user",content:i}],d={type:"object",properties:{result:{type:"array",items:{type:"object",properties:{n:{type:"array",items:{type:"object",properties:{p:{type:"string"},s:{type:"number"},d:{type:"number"}},required:["p","s","d"],additionalProperties:!1}}},required:["n"],additionalProperties:!1}}},required:["result"],additionalProperties:!1};try{const c=await R.responseCompletion(o,d,{model:r,temperature:.3,name:"track_array"});return console.log("Received response from openAI"),console.log(c),J(c)}catch(c){throw console.error("AI extension failed:",c),new Error("Failed to extend tracks with AI.")}}function L(e){if(!Array.isArray(e))throw new Error("sequencers must be an array.");return e.map(t=>{if(!t||!Array.isArray(t.notes))throw new Error("Invalid sequencer object encountered during conversion.");return{n:t.notes.map(n=>[n.pitch,n.start,n.duration])}})}function _(e,t,n){if(!e||!Array.isArray(e.n))throw new Error("Invalid trackMap provided.");return{n:e.n.filter(([s,i,o])=>{const d=i+o;return i>=t&&d<=n})}}function F(e,t,n){if(!Array.isArray(e))throw new Error("trackMaps must be an array.");return e.map(r=>_(r,t,n))}function q(e,t){if(!(e!=null&&e.n)||!(t!=null&&t.n))throw new Error("Invalid track maps provided.");return{n:[...e.n,...t.n]}}function K(e,t){if(!Array.isArray(e)||!Array.isArray(t))throw new Error("Both track arrays must be arrays.");if(e.length!==t.length)throw new Error("Track arrays must have the same number of tracks.");return e.map((n,r)=>q(n,t[r]))}async function z(){var t;const e=document.getElementById("ai-working-modal");e.classList.remove("hidden");try{const n=v(),r=Array.from(document.querySelectorAll('#extend-track-checkboxes input[type="checkbox"]:checked')).map(a=>parseInt(a.dataset.index,10));if(r.length===0){console.warn("No tracks selected for AI extension."),e.classList.add("hidden");return}const s=r.map(a=>n[a]),i=O(),o=Math.max(0,i-M()),d=i,c=L(s),l=F(c,o,d),u=await B(l,S());if(console.log("ðŸ§  AI Extension Result:",u),!u||u.length!==s.length)throw new Error("AI response did not return expected number of tracks.");const p=K(c,u),x=p.flatMap(a=>a.n.map(m=>m[1]+m[2])),E=Math.max(...x),y=Math.ceil(E/T());k(y),n.forEach((a,m)=>{var w;a.updateTotalMeasures(y);const f=r.indexOf(m);if(f!==-1){const b=p[f];a.updateNotesFromTrackMap(b)}(w=a.grid)==null||w.scheduleRedraw();const g=a.container.querySelector("canvas.mini-contour");g&&N(g,a.notes,a.config,a.colorIndex)});const h=document.getElementById("global-mini-contour");h&&j(h,n),console.log("ðŸŽ¼ Sequencers updated with AI-generated continuation."),console.log(`ðŸŽ¼ Total measures extended to ${y} based on AI content.`),(t=document.getElementById("ai-extend-modal"))==null||t.classList.add("hidden"),e.classList.add("hidden")}catch(n){console.error("Error during AI extension:",n),e.classList.add("hidden");const r=document.getElementById("ai-generation-failed-modal");r.classList.remove("hidden"),document.getElementById("generation-failed-ok").addEventListener("click",()=>{r.classList.add("hidden")},{once:!0})}}export{z as extendTracksWithAI};
